<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    
    <title>Keith J. Grant</title>
    
    <link>http://keithjgrant.com/index.xml</link>
    <description>Recent content in Keith J. Grant on Keith J. Grant</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 24 Mar 2017 14:15:34 -0400</lastBuildDate>
    <link rel="hub"  href="https://keithjgrant.superfeedr.com/" xmlns="http://www.w3.org/2005/Atom" />
    <link rel="self" href="http://keithjgrant.com/index.xml" xmlns="http://www.w3.org/2005/Atom" />
    
    <item>
      <title>CSS is Not Broken</title>
      <link>http://keithjgrant.com/posts/2017/03/css-is-not-broken/</link>
      <pubDate>Fri, 24 Mar 2017 14:15:34 -0400</pubDate>
      
      <guid>http://keithjgrant.com/posts/2017/03/css-is-not-broken/</guid>
      <description>&lt;p&gt;Coding in any language is hard before you spend time mastering it. Imagine what your JavaScript would look like if you never took the time to learn about OOP or functional programming principles? Just because you &lt;em&gt;expect&lt;/em&gt; CSS to be easy, doesn’t mean the language is broken when you find it is not.&lt;/p&gt;

&lt;p&gt;A lot of people have &lt;a href=&#34;https://simpleprogrammer.com/2013/05/06/why-javascript-is-doomed/&#34;&gt;gone on about&lt;/a&gt; &lt;a href=&#34;https://medium.com/smalltalk-talk/the-three-worst-programming-languages-b1ec25a232c1#e848&#34;&gt;how horrible JavaScript is&lt;/a&gt;. JavaScript is not horrible. It is an incredible language. It has a few odd quirks, just as CSS does. But if you take the time to actually understand these quirks, you will reap huge reward.&lt;/p&gt;

&lt;p&gt;You cannot be proficient in JavaScript until you understand coercion, prototypal inheritance, and asyncronous flow control. Likewise, in CSS, you have to understand the cascade, inheritance, and the box model. Once you have those down, take a deeper look at the various layout methods. Do you know what stacking contexts and block formatting contexts are? Do you know why setting a height on an element leads to problems and how to accomplish what you need without doing so?&lt;/p&gt;

&lt;p&gt;CSS is hard. But this is not because the language is faulty. Rather, the difficulty lies in what the language seeks to accomplish. I’ve heard many developers say they wish they could “throw out CSS and start over with something better.” I think this betrays a fundamental misunderstanding of the purpose of the language:&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-conversation=&#34;none&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;When you code CSS, you’re writing abstract rules to take &lt;em&gt;unknown&lt;/em&gt; content and organize it in an &lt;em&gt;unknown&lt;/em&gt; medium. That shit is hard.&lt;/p&gt;&amp;mdash; keith•j•grant (@keithjgrant) &lt;a href=&#34;https://twitter.com/keithjgrant/status/842728744653676544&#34;&gt;March 17, 2017&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Furthermore, CSS isn’t just code, it’s also part of the design. A &lt;a href=&#34;https://snook.ca/archives/html_and_css/css-concerns&#34;&gt;vital concern of CSS is consistency&lt;/a&gt;. You should want “global” styles: colors and spacing should be consistent throughout your application. Similar components need to look similar. Your buttons should all be consistently sized and your box shadows or border radiuses should not be ad-hoc.&lt;/p&gt;

&lt;p&gt;I find it ironic that developers who bemoan the “global” nature of CSS are usually the ones who run into specificity problems because they unnecessarily scope their styles to particular parts of a particular page. When you have selectors like &lt;code&gt;#directory .sorted .sidebar :nth-child(2) button&lt;/code&gt;, your problem isn’t that CSS is global. Your CSS isn’t global enough!&lt;/p&gt;

&lt;p&gt;The next thing you know, you find yourself using &lt;code&gt;!important&lt;/code&gt; to correct specificity problems. This is a red flag that you need to stop and learn the cascade. You can use &lt;code&gt;!important&lt;/code&gt; to sweep specificity problems under the rug once. But you will soon need it a second time, at which point you will face the same specificity problem all over again.&lt;/p&gt;

&lt;p&gt;Design your styles so they can be reused, anywhere in the app. Learn SMACSS and BEM. And don’t stop because you understand the “naming system”&amp;mdash;these methodologies are about far more than double-underscores and double-hyphens. They are about code organization, reuse, and refactoring. They are the solution to dead code elimination. They offer ways to utilize the cascade instead of fearing it. They allow you to know precisely where in your code you can find a certain set of styles.&lt;/p&gt;

&lt;p&gt;CSS isn’t broken. But it does require &lt;a href=&#34;https://www.manning.com/books/css-in-depth&#34;&gt;study and skill&lt;/a&gt;. It does require careful thought. As with anything in programming, you can make a mess of the code. Sure, blaming the language is the easy way out. But when your JavaScript is confusing and buggy, you know it’s not the language’s fault.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://keithjgrant.com/notes/2017/03/73954/</link>
      <pubDate>Mon, 20 Mar 2017 20:32:34 +0000</pubDate>
      
      <guid>http://keithjgrant.com/notes/2017/03/73954/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>http://keithjgrant.com/likes/2017/03/73775/</link>
      <pubDate>Mon, 20 Mar 2017 20:29:35 +0000</pubDate>
      
      <guid>http://keithjgrant.com/likes/2017/03/73775/</guid>
      <description></description>
    </item>
    
    <item>
      <title>More thoughts on CSS in JS</title>
      <link>http://keithjgrant.com/posts/2017/03/more-thoughts-on-css-in-js/</link>
      <pubDate>Mon, 20 Mar 2017 15:07:49 -0400</pubDate>
      
      <guid>http://keithjgrant.com/posts/2017/03/more-thoughts-on-css-in-js/</guid>
      <description>&lt;p&gt;At a previous job, I was brought in to a team of Java devs to provide a little JS support. They had been using something called PrimeFaces, basically a bunch of front-end components you drop into JSF pages. Working with it was horrid.&lt;/p&gt;

&lt;p&gt;In short, these devs knew nothing about JavaScript or the front-end, but this tool let them sort of hack a UI together. It abstracted away all the tools needed for really working in the front end. For me, someone adept in JavaScript, working with PrimeFaces was like trying to code without a keyboard.&lt;/p&gt;

&lt;p&gt;I’ve also had to work on projects coded in ExtJS. These feel about the same way: although you are technically editing a JS file, you aren’t really programming “in JavaScript.” Instead, you are basically coding via configuration. Actual understanding of JavaScript doesn’t help you much.&lt;/p&gt;

&lt;p&gt;To me, CSS in JS feels the same way. It feels like a tool so a bunch of JavaScript devs can kinda-sorta hack together styles without actually having to write CSS. Except the syntax is more clunky and you have taken away the cascade. (And, yet, surprise! You still need to learn the most complicated parts of CSS.)&lt;/p&gt;

&lt;p&gt;Now I’ll be fair, CSS in JS libraries typically provide a much thinner buffer between you and the actual CSS when compared to PrimeFaces. But still… it’s an abstraction layer. It gives the illusion of writing styles in perfect isolation, but inheritance still takes place and can interfere. It gets between me and the code I want actual control over.&lt;/p&gt;

&lt;p&gt;I know what I’m doing when I code CSS. I &lt;em&gt;want&lt;/em&gt; the cascade in many instances; removing it feels crippling. I won’t deny CSS in JS offers some benefits. But they are benefits I am not convinced I need at a cost I am not sure I want to pay.&lt;/p&gt;

&lt;p&gt;I won’t say it’s the wrong choice for everyone. Some folks who really do grok CSS are in favor of it. Sometimes ExtJS is the right choice (don’t quote me on that). But dang, please know it’s a compromise that someone might have to clean up down the road.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://keithjgrant.com/likes/2017/03/65329/</link>
      <pubDate>Mon, 20 Mar 2017 18:08:49 +0000</pubDate>
      
      <guid>http://keithjgrant.com/likes/2017/03/65329/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>http://keithjgrant.com/notes/2017/03/48158/</link>
      <pubDate>Fri, 17 Mar 2017 13:22:38 +0000</pubDate>
      
      <guid>http://keithjgrant.com/notes/2017/03/48158/</guid>
      <description>&lt;p&gt;Developers somehow acquired the idea that CSS should be easy. Like, learn in a weekend easy.&lt;/p&gt;

&lt;p&gt;CSS isn’t like that. Nobody &lt;em&gt;in the world&lt;/em&gt; knows all of CSS. You need to commit to learning it just as you do conventional programming.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A better approach to CSS aspect ratios</title>
      <link>http://keithjgrant.com/posts/2017/03/aspect-ratios/</link>
      <pubDate>Tue, 14 Mar 2017 10:12:43 -0400</pubDate>
      
      <guid>http://keithjgrant.com/posts/2017/03/aspect-ratios/</guid>
      <description>

&lt;p&gt;There’s an old hack for creating elements with a fixed aspect ratio that involves using a percentage-based padding. You may be familiar with it. It looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.tile {
  height: 0;
  overflow: hidden;
  padding-bottom: 25%;
  background-color: bisque;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The element is forced to have no height, then its bottom padding is set to the actual desired height. This produces an element something like this:&lt;/p&gt;

&lt;figure class=&#34;-demo-container&#34;&gt;
  &lt;div class=&#34;-demo1&#34;&gt;
    4:1 aspect ratio
  &lt;/div&gt;
&lt;/figure&gt;

&lt;p&gt;This works because of a peculiar quirk of padding: Any padding specified in percent computes to a percentage of the element’s &lt;em&gt;width&lt;/em&gt;&amp;mdash;even if it is a top or bottom padding. (The same is true for margin as well.) This is a bit counter-intuitive, but it comes in handy. I think the original reasoning was so you could declare something like &lt;code&gt;padding: 5%&lt;/code&gt; and get an equal padding on all four sides of the element, regardless of its shape.&lt;/p&gt;

&lt;p&gt;Of course, this approach has a problem: overflow is cut off:&lt;/p&gt;

&lt;figure class=&#34;-demo-container&#34;&gt;
  &lt;div class=&#34;-demo1&#34;&gt;
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam laoreet tellus ut erat egestas vestibulum. Aliquam erat volutpat. Fusce ut nibh quis lectus fermentum aliquet. Suspendisse potenti.
  &lt;/div&gt;
&lt;/figure&gt;

&lt;p&gt;This approach creates fixed height of the element, which in CSS is an anti-pattern. For this reason, I’ve always felt dirty using it.&lt;/p&gt;

&lt;h2 id=&#34;dealing-with-overflow&#34;&gt;Dealing with overflow&lt;/h2&gt;

&lt;p&gt;A while back, I stumbled across an approach that is similar, but prevents the overflow problem. Instead of setting our element’s height, we can set the height on a floated &lt;code&gt;::before&lt;/code&gt; pseudo-element. Watch what happens when we do this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;.tile {
  background-color: darkseagreen;
}
.tile::before {
  content: &amp;quot;&amp;quot;;
  float: left;
  padding-bottom: 25%;
}
.tile::after {
  clear: left;
  content: &amp;quot; &amp;quot;;
  display: table;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;::after&lt;/code&gt; is just a familiar clearfix. This produces a very similar result:&lt;/p&gt;

&lt;figure class=&#34;-demo-container&#34;&gt;
  &lt;div class=&#34;-demo2&#34;&gt;
    4:1 aspect ratio
  &lt;/div&gt;
&lt;/figure&gt;

&lt;p&gt;However, the element will still grow to contain overflow if necessary:&lt;/p&gt;

&lt;figure class=&#34;-demo-container&#34;&gt;
  &lt;div class=&#34;-demo2&#34;&gt;
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam laoreet tellus ut erat egestas vestibulum. Aliquam erat volutpat. Fusce ut nibh quis lectus fermentum aliquet. Suspendisse potenti.
  &lt;/div&gt;
&lt;/figure&gt;

&lt;h2 id=&#34;how-it-works&#34;&gt;How it works&lt;/h2&gt;

&lt;p&gt;The trick is, instead of explicitly controlling (and thus limiting) the height of the element, we set a known height on the floated pseudo element. By using a padding-based percentage, this will be a ratio of the element’s width. We float it left and leave it empty, producing a width of zero. Here is the floated element, with a black outline added:&lt;/p&gt;

&lt;figure class=&#34;-demo-container&#34;&gt;
  &lt;div class=&#34;-demo3&#34;&gt;
    Floated pseudo element provides a min height to the element.
  &lt;/div&gt;
&lt;/figure&gt;

&lt;p&gt;Then, in the &lt;code&gt;::after&lt;/code&gt; pseudo-element, we clear the float, forcing the element to grow to contain the floated &lt;code&gt;::before&lt;/code&gt;. Since the float has a width of 0, it doesn’t interfere with the content layout in any way.  And when the content extends below the bottom of the float, the box simply grows naturally to contain it:&lt;/p&gt;

&lt;figure class=&#34;-demo-container&#34;&gt;
  &lt;div class=&#34;-demo3&#34;&gt;
    Lorem ipsum dolor sit amet, consectetur adipiscing elit. Etiam laoreet tellus ut erat egestas vestibulum. Aliquam erat volutpat. Fusce ut nibh quis lectus fermentum aliquet. Suspendisse potenti.
  &lt;/div&gt;
&lt;/figure&gt;

&lt;style&gt;
  .-demo-container {
    max-width: 300px;
    line-height: 1.6;
  }

  .-demo1 {
    height: 0;
    overflow: hidden;
    padding-bottom: 25%;
    background-color: bisque;
  }

  .-demo2 {
    background-color: darkseagreen;
    line-height: 1.6;
  }
  .-demo2::before {
    content: &#34;&#34;;
    float: left;
    padding-bottom: 25%;
  }
  .-demo2::after {
    clear: left;
    content: &#34; &#34;;
    display: table;
  }

  .-demo3 {
    background-color: darkseagreen;
    line-height: 1.6;
  }
  .-demo3::before {
    content: &#34;&#34;;
    float: left;
    padding-bottom: 25%;
    border: 1px solid black;
  }
  .-demo3::after {
    clear: left;
    content: &#34; &#34;;
    display: table;
  }
&lt;/style&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://keithjgrant.com/likes/2017/03/45532/</link>
      <pubDate>Tue, 14 Mar 2017 12:38:52 +0000</pubDate>
      
      <guid>http://keithjgrant.com/likes/2017/03/45532/</guid>
      <description></description>
    </item>
    
    <item>
      <title></title>
      <link>http://keithjgrant.com/notes/2017/03/68059/</link>
      <pubDate>Mon, 13 Mar 2017 18:54:19 +0000</pubDate>
      
      <guid>http://keithjgrant.com/notes/2017/03/68059/</guid>
      <description>&lt;p&gt;I’m still fascinated that JavaScript—which only runs on one thread—is the language that popularized functional, async programming, which is needed for multi-threaded programming.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title></title>
      <link>http://keithjgrant.com/notes/2017/03/66211/</link>
      <pubDate>Mon, 13 Mar 2017 18:23:31 +0000</pubDate>
      
      <guid>http://keithjgrant.com/notes/2017/03/66211/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
